#!/usr/bin/env python

# Autobahn and Twisted imports
from autobahn.twisted.wamp import ApplicationSession, ApplicationRunner
from twisted.internet.defer import inlineCallbacks, returnValue
from twisted.internet.protocol import ReconnectingClientFactory
from twisted.internet import reactor, defer
from autobahn.twisted import wamp, websocket
from autobahn.twisted.util import sleep
from autobahn.wamp import types



# OSLO imports
from oslo_config import cfg
from oslo_log import log as logging

# MODULES imports
from stevedore import extension, named
import pkg_resources
import inspect
import threading
from lightningrod.config import mod_queue



# LR configuration
lr_conf_file = "lr_settings"
"""
wamp_opts = [
   cfg.StrOpt('wamp_url',
              default='ws://192.168.17.1:8181/ws',
              help=('URL of wamp broker')),
   cfg.StrOpt('wamp_realm',
              default='s4t',
              help=('realm broker')),
]
"""  
  
  
wamp_opts = [
    cfg.StrOpt('wamp_ip',
               default='192.168.17.1',
               help=('URL of wamp broker')),
    cfg.IntOpt('wamp_port',
               default=8181,
               help='port wamp broker'),
    cfg.StrOpt('wamp_realm',
               default='s4t',
               help=('realm broker')),
]
  
  
  
  
log_opts = [
   cfg.StrOpt('log_level',
              default='info',
              help=('Logging level')),
   cfg.StrOpt('log_file',
              default='s4t-lightning-rod.log',
              help=('Lightning-rod log file')),
]  

CONF = cfg.CONF
CONF.register_opts(wamp_opts, 'wamp')
CONF.register_opts(log_opts, 'logging')

#print CONF.__dict__

# Logging configuration
LOG = logging.getLogger(__name__)
CONF.log_file = "/var/log/s4t-lightning-rod.log"
CONF.debug = False

DOMAIN = "s4t-lightning-rod"
logging.register_options(CONF)
logging.setup(CONF, DOMAIN)


"""
def listener_q(session):
  
    print "Queue new modules linestining..."
  
    while True:
	  print "Waiting for new module function registration..."
	  
	  new_module = mod_queue.get()
	  
	  print "Function dequeued: "+str(new_module)
	  
	  #session.register(inlineCallbacks(meth[1]), u'board.'+meth[0])
	  #print "Function registered: "+str(meth[0])

	  session.disconnect()
	  
"""


def modulesLoader(session):
    '''
    Modules loader method thorugh stevedore libraries.
    '''          
    print "Available modules: "
    
    ep=[] 

    for ep in pkg_resources.iter_entry_points(group='s4t.modules'):
	print " - "+str(ep)


    if not ep:
      
	print "No modules available!"
	LOG.info("No modules available!")
	sys.exit()

    else:

	modules = extension.ExtensionManager(
		namespace='s4t.modules',
		#invoke_on_load=True,
		#invoke_args=(session,),
	)
		
	for ext in modules.extensions:
	  
	  mod = ext.plugin(session)
	  #print mod.name
	  
	  meth_list = inspect.getmembers(mod, predicate=inspect.ismethod)
	  
	  for meth in meth_list[1:]:		#We don't considere the __init__ method
	     print " - " + str(meth)
	     session.register(inlineCallbacks(meth[1]), u'board.'+meth[0])
	     
	""" 
	t = threading.Thread(target=listener_q, args=(session,))
	t.start()
	"""
            


	  

  

class WampFrontend(ApplicationSession):

    @inlineCallbacks
    def onJoin(self, details):
      
        print("WAMP server session ready!")
        
        
        # BOARD REGISTRAION
        try: 
	    res = yield self.call(u'register_board') 
	    LOG.info("Board registration call result: {}".format(res)) 
	except Exception as e: 
	    LOG.warning("Board registration call error: {0}".format(e))
	
	
	try:
	  
            yield modulesLoader(self) #self.register(pinco, u'com.myapp.hello')
            LOG.info("Procedures registered!")
            

        except Exception as e:
            LOG.warning("WARNING - Could not register procedures: {0}".format(e))
	
       
       
    def onLeave(self, details):
        LOG.info('session left: {}'.format(details))
        
    """
    def onConnect(self):
        LOG.info('transport connected')
        
    def onDisconnect(self):
        LOG.info('transport disconnected')        
    """   
       
       
       
class WampClientFactory(websocket.WampWebSocketClientFactory, ReconnectingClientFactory):
    maxDelay = 30

    def clientConnectionFailed(self, connector, reason):
        #print "reason:", reason
        LOG.warning("Wamp Connection Failed.")
        ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)

    def clientConnectionLost(self, connector, reason):
        #print "reason:", reason
        LOG.warning("Wamp Connection Lost.")
        ReconnectingClientFactory.clientConnectionLost(self, connector, reason)

        
        
class WampManager(object):
  
    def __init__(self):
      component_config = types.ComponentConfig(realm = unicode(CONF.wamp.wamp_realm))
      session_factory = wamp.ApplicationSessionFactory(config = component_config)
      session_factory.session = WampFrontend


      transport_factory = WampClientFactory(session_factory)
      transport_factory.host = CONF.wamp.wamp_ip
      transport_factory.port = CONF.wamp.wamp_port
      
      transport_factory.autoPingInterval = 1
      transport_factory.autoPingTimeout = 1
      
      LOG.debug("\nWamp IP: %s\nWamp Port: %s\nWamp realm: %s\n", CONF.wamp.wamp_ip, CONF.wamp.wamp_port, CONF.wamp.wamp_realm)
      websocket.connectWS(transport_factory)

    def start(self):
        LOG.info("Starting WAMP server...")
        reactor.run()

    def stop(self):
        LOG.info("Stopping WAMP-agent server...")
        reactor.stop()
        LOG.info("WAMP server stopped.")



if __name__ == '__main__':
    """
    runner = ApplicationRunner(url=unicode(CONF.wamp.wamp_url), realm=unicode(CONF.wamp.wamp_realm))
    runner.run(WampFrontend)
    """

    w=WampManager()

    try:
	w.start()
    except KeyboardInterrupt:
	w.stop()
	exit()
                              
    
    
    
